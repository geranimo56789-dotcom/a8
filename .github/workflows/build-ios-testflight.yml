name: Build and Upload iOS (TestFlight)

on:
  workflow_dispatch:
    inputs:
      bundle_id:
        description: iOS bundle identifier (e.g. com.company.app)
        required: false
        default: ''
      team_id:
        description: Apple Developer Team ID (10-character)
        required: false
        default: ''
      flavor:
        description: Flutter flavor (optional)
        required: false
        default: ''
      build_name:
        description: App version name (e.g. 1.0.0)
        required: false
        default: ''
      build_number:
        description: App build number (e.g. 1)
        required: false
        default: ''
  push:
    branches:
      - main
    paths:
      - 'ios/**'
      - '.github/workflows/build-ios-testflight.yml'

permissions:
  contents: read

env:
  # Prefer repository/environment variables; workflow inputs override if provided.
  IOS_BUNDLE_ID: ${{ inputs.bundle_id != '' && inputs.bundle_id || vars.IOS_BUNDLE_ID }}
  IOS_DEVELOPMENT_TEAM: ${{ inputs.team_id != '' && inputs.team_id || vars.IOS_DEVELOPMENT_TEAM }}

jobs:
  build-sign-upload:
    name: Build signed IPA and upload to TestFlight
    runs-on: macos-14
    timeout-minutes: 75

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Compute auth flags
        id: auth
        env:
          APPSTORE_PRIVATE_KEY: ${{ secrets.APPSTORE_PRIVATE_KEY }}
          APPSTORE_KEY_ID: ${{ secrets.APPSTORE_KEY_ID }}
          APPSTORE_ISSUER_ID: ${{ secrets.APPSTORE_ISSUER_ID }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APP_SPECIFIC_PASSWORD: ${{ secrets.APP_SPECIFIC_PASSWORD }}
        shell: bash
        run: |
          set -e
          has_api="false"
          has_apple_id="false"
          if [ -n "$APPSTORE_PRIVATE_KEY" ] && [ -n "$APPSTORE_KEY_ID" ] && [ -n "$APPSTORE_ISSUER_ID" ]; then
            has_api="true"
          fi
          if [ -n "$APPLE_ID" ] && [ -n "$APP_SPECIFIC_PASSWORD" ]; then
            has_apple_id="true"
          fi
          echo "has_api=$has_api" >> $GITHUB_OUTPUT
          echo "has_apple_id=$has_apple_id" >> $GITHUB_OUTPUT

      - name: Set up Java (for Gradle/Android tooling used by Flutter)
        uses: actions/setup-java@v4
        with:
          distribution: 'zulu'
          java-version: '17'

      - name: Set up Flutter
        uses: subosito/flutter-action@v2
        with:
          channel: stable

      - name: Flutter version
        run: flutter --version

      - name: Flutter precache iOS
        run: flutter precache --ios

      - name: Cache pub packages
        uses: actions/cache@v4
        with:
          path: |
            ~/.pub-cache
            .dart_tool
          key: ${{ runner.os }}-pub-${{ hashFiles('pubspec.lock') }}

      - name: Cache CocoaPods
        uses: actions/cache@v4
        with:
          path: |
            ~/.cocoapods
            ios/Pods
          key: ${{ runner.os }}-pods-${{ hashFiles('ios/Podfile.lock') }}

      - name: Flutter pub get
        run: flutter pub get

      - name: Install CocoaPods dependencies (best-effort)
        if: ${{ hashFiles('ios/Podfile') != '' }}
        env:
          COCOAPODS_DISABLE_STATS: 'true'
        run: |
          set -e
          cd ios
          if command -v pod >/dev/null 2>&1; then
            pod install --repo-update || echo "pod install failed; continuing to let flutter build drive pods"
          else
            echo "CocoaPods not available; continuing"
          fi

      - name: Validate required inputs
        run: |
          set -e
          if [ -z "${IOS_BUNDLE_ID}" ]; then echo "Missing IOS_BUNDLE_ID (set vars.IOS_BUNDLE_ID or provide input bundle_id)"; exit 1; fi
          if [ -z "${IOS_DEVELOPMENT_TEAM}" ]; then echo "Missing IOS_DEVELOPMENT_TEAM (set vars.IOS_DEVELOPMENT_TEAM or provide input team_id)"; exit 1; fi

      - name: Import code signing certificate (.p12)
        uses: apple-actions/import-codesign-certs@v1
        with:
          p12-file-base64: ${{ secrets.IOS_CERT_P12_BASE64 }}
          p12-password: ${{ secrets.IOS_CERT_PASSWORD }}

      - name: Write App Store Connect API key to file
        if: steps.auth.outputs.has_api == 'true'
        # Needed for -allowProvisioningUpdates and TestFlight upload when using API key
        env:
          APPSTORE_PRIVATE_KEY: ${{ secrets.APPSTORE_PRIVATE_KEY }}
        run: |
          set -e
          echo "$APPSTORE_PRIVATE_KEY" > "$RUNNER_TEMP/AuthKey.p8"
          chmod 600 "$RUNNER_TEMP/AuthKey.p8"

      # When API key is provided, we'll use Automatic signing with -allowProvisioningUpdates
      # and let Xcode manage the profile. No need to download a profile.

      - name: Install provisioning profile from secret (base64)
        if: steps.auth.outputs.has_api != 'true'
        env:
          IOS_MOBILEPROVISION_BASE64: ${{ secrets.IOS_MOBILEPROVISION_BASE64 }}
        run: |
          set -e
          mkdir -p "${HOME}/Library/MobileDevice/Provisioning Profiles"
          if [ -z "$IOS_MOBILEPROVISION_BASE64" ]; then echo "IOS_MOBILEPROVISION_BASE64 not set"; exit 1; fi
          echo "Installing provisioning profile from IOS_MOBILEPROVISION_BASE64"
          echo "$IOS_MOBILEPROVISION_BASE64" | base64 --decode > "${HOME}/Library/MobileDevice/Provisioning Profiles/profile.mobileprovision"

      - name: Fail if no provisioning profile configured
        if: steps.auth.outputs.has_api != 'true'
        env:
          IOS_MOBILEPROVISION_BASE64: ${{ secrets.IOS_MOBILEPROVISION_BASE64 }}
        run: |
          if [ -z "$IOS_MOBILEPROVISION_BASE64" ]; then
            echo "No provisioning profile available. Provide either API key secrets (APPSTORE_PRIVATE_KEY/KEY_ID/ISSUER_ID) or a base64 provisioning profile in IOS_MOBILEPROVISION_BASE64." >&2
            exit 1
          fi

      - name: Resolve provisioning profile name (manual signing only)
        if: steps.auth.outputs.has_api != 'true'
        id: profile
        shell: bash
        run: |
          set -e
          PROFILE_PATH=$(ls -1 "${HOME}/Library/MobileDevice/Provisioning Profiles"/*.mobileprovision | head -n1)
          if [ ! -f "$PROFILE_PATH" ]; then echo "No provisioning profile found"; exit 1; fi
          /usr/bin/security cms -D -i "$PROFILE_PATH" -o profile.plist
          NAME=$(/usr/libexec/PlistBuddy -c 'Print :Name' profile.plist)
          UUID=$(/usr/libexec/PlistBuddy -c 'Print :UUID' profile.plist)
          echo "Profile: $NAME ($UUID)"
          echo "name=$NAME" >> $GITHUB_OUTPUT
          echo "uuid=$UUID" >> $GITHUB_OUTPUT

      - name: Archive (Xcode) with manual signing
        env:
          HAS_API: ${{ steps.auth.outputs.has_api }}
        run: |
          set -euo pipefail
          mkdir -p build/ios/archive build/ios/logs
          echo "Listing Xcode schemes to verify 'Runner' exists:"
          xcodebuild -list -workspace ios/Runner.xcworkspace || true
          AUTH_ARGS=()
          if [ "${HAS_API}" = "true" ]; then
            AUTH_ARGS+=(
              -allowProvisioningUpdates
              -authenticationKeyPath "$RUNNER_TEMP/AuthKey.p8"
              -authenticationKeyID "${{ secrets.APPSTORE_KEY_ID }}"
              -authenticationKeyIssuerID "${{ secrets.APPSTORE_ISSUER_ID }}"
            )
          fi
          SIGN_ARGS=()
          if [ "${HAS_API}" = "true" ]; then
            # Force distribution identity for Release archive to avoid CI trying to generate a Development cert
            SIGN_ARGS+=(CODE_SIGN_STYLE=Automatic CODE_SIGN_IDENTITY="Apple Distribution")
          else
            SIGN_ARGS+=(CODE_SIGN_STYLE=Manual PROVISIONING_PROFILE_SPECIFIER='${{ steps.profile.outputs.name }}')
          fi
          xcodebuild \
            -workspace ios/Runner.xcworkspace \
            -scheme Runner \
            -configuration Release \
            -destination 'generic/platform=iOS' \
            -archivePath build/ios/archive/Runner.xcarchive \
            DEVELOPMENT_TEAM=${IOS_DEVELOPMENT_TEAM} \
            PRODUCT_BUNDLE_IDENTIFIER=${IOS_BUNDLE_ID} \
            ${SIGN_ARGS[@]} \
            clean archive \
            ${AUTH_ARGS[@]} \
            | tee build/ios/logs/xcodebuild-archive.log
          echo "\nSelected signing identity during archive (detected from build settings):" || true
          xcodebuild -showBuildSettings -workspace ios/Runner.xcworkspace -scheme Runner -configuration Release | grep -E "CODE_SIGN_IDENTITY|CODE_SIGN_STYLE" || true

      - name: Create exportOptions.plist (App Store)
        env:
          HAS_API: ${{ steps.auth.outputs.has_api }}
        run: |
          if [ "${HAS_API}" = "true" ]; then
            cat > exportOptions.plist <<EOF
            <?xml version="1.0" encoding="UTF-8"?>
            <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
            <plist version="1.0">
            <dict>
              <key>method</key>
              <string>app-store</string>
              <key>signingStyle</key>
              <string>automatic</string>
              <key>teamID</key>
              <string>${IOS_DEVELOPMENT_TEAM}</string>
              <key>compileBitcode</key>
              <false/>
              <key>uploadSymbols</key>
              <true/>
              <key>manageAppVersionAndBuildNumber</key>
              <true/>
            </dict>
            </plist>
            EOF
          else
            cat > exportOptions.plist <<EOF
            <?xml version="1.0" encoding="UTF-8"?>
            <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
            <plist version="1.0">
            <dict>
              <key>method</key>
              <string>app-store</string>
              <key>signingStyle</key>
              <string>manual</string>
              <key>teamID</key>
              <string>${IOS_DEVELOPMENT_TEAM}</string>
              <key>provisioningProfiles</key>
              <dict>
                <key>${IOS_BUNDLE_ID}</key>
                <string>${{ steps.profile.outputs.name }}</string>
              </dict>
              <key>compileBitcode</key>
              <false/>
              <key>uploadSymbols</key>
              <true/>
              <key>manageAppVersionAndBuildNumber</key>
              <true/>
            </dict>
            </plist>
            EOF
          fi

      - name: Export signed IPA
        env:
          HAS_API: ${{ steps.auth.outputs.has_api }}
        run: |
          set -euo pipefail
          mkdir -p build/ios/ipa build/ios/logs
          # Optionally set version/build via xcodebuild overrides if provided
          EXTRA_BUILD_ARGS=()
          if [ -n "${{ inputs.build_name }}" ]; then EXTRA_BUILD_ARGS+=(MARKETING_VERSION=${{ inputs.build_name }}); fi
          if [ -n "${{ inputs.build_number }}" ]; then EXTRA_BUILD_ARGS+=(CURRENT_PROJECT_VERSION=${{ inputs.build_number }}); fi
          AUTH_ARGS=()
          if [ "${HAS_API}" = "true" ]; then
            AUTH_ARGS+=(
              -allowProvisioningUpdates
              -authenticationKeyPath "$RUNNER_TEMP/AuthKey.p8"
              -authenticationKeyID "${{ secrets.APPSTORE_KEY_ID }}"
              -authenticationKeyIssuerID "${{ secrets.APPSTORE_ISSUER_ID }}"
            )
          fi
          xcodebuild -exportArchive \
            -archivePath build/ios/archive/Runner.xcarchive \
            -exportOptionsPlist exportOptions.plist \
            -exportPath build/ios/ipa \
            ${AUTH_ARGS[@]} \
            ${EXTRA_BUILD_ARGS[@]} \
            | tee build/ios/logs/xcodebuild-export.log

      - name: Upload to TestFlight (API key)
        if: steps.auth.outputs.has_api == 'true'
        uses: apple-actions/upload-testflight-build@v1
        with:
          app-path: build/ios/ipa/*.ipa
          issuer-id: ${{ secrets.APPSTORE_ISSUER_ID }}
          api-key-id: ${{ secrets.APPSTORE_KEY_ID }}
          api-private-key: ${{ secrets.APPSTORE_PRIVATE_KEY }}

      - name: Upload to TestFlight (Apple ID + app-specific password)
        if: steps.auth.outputs.has_api != 'true'
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APP_SPECIFIC_PASSWORD: ${{ secrets.APP_SPECIFIC_PASSWORD }}
          ITC_PROVIDER: ${{ secrets.ITC_PROVIDER }}
        run: |
          set -e
          IPA=$(ls -1 build/ios/ipa/*.ipa | head -n1)
          if [ ! -f "$IPA" ]; then echo "IPA not found"; exit 1; fi
          echo "Uploading via iTMSTransporter using Apple ID"
          # Optional provider short name (when Apple ID is in multiple teams)
          if [ -z "$APPLE_ID" ] || [ -z "$APP_SPECIFIC_PASSWORD" ]; then echo "APPLE_ID/APP_SPECIFIC_PASSWORD not set"; exit 1; fi
          if [ -n "$ITC_PROVIDER" ]; then
            xcrun iTMSTransporter -m upload -assetFile "$IPA" -u "$APPLE_ID" -p "$APP_SPECIFIC_PASSWORD" -itc_provider "$ITC_PROVIDER" -repetitionAttempts 3 -v informational
          else
            xcrun iTMSTransporter -m upload -assetFile "$IPA" -u "$APPLE_ID" -p "$APP_SPECIFIC_PASSWORD" -repetitionAttempts 3 -v informational
          fi

      - name: Fail upload if no credentials provided
        if: steps.auth.outputs.has_api != 'true'
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APP_SPECIFIC_PASSWORD: ${{ secrets.APP_SPECIFIC_PASSWORD }}
        run: |
          if [ -z "$APPLE_ID" ] || [ -z "$APP_SPECIFIC_PASSWORD" ]; then
            echo "No TestFlight upload credentials provided. Provide API key secrets or APPLE_ID + APP_SPECIFIC_PASSWORD (and optional ITC_PROVIDER)." >&2
            exit 1
          fi

      - name: Upload artifacts (IPA + XCArchive)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: ios-signed-artifacts
          path: |
            build/ios/ipa/*.ipa
            build/ios/archive/*.xcarchive
            build/ios/logs/*.log
          retention-days: 7
