name: Build and Upload iOS (TestFlight)

on:
  workflow_dispatch:
    inputs:
      bundle_id:
        description: iOS bundle identifier (e.g. com.company.app)
        required: false
        default: ''
      team_id:
        description: Apple Developer Team ID (10-character)
        required: false
        default: ''
      signing_mode:
        description: Signing mode (auto uses App Store Connect API key if provided; manual uses provisioning profile secret)
        required: false
        default: 'manual'
      flavor:
        description: Flutter flavor (optional)
        required: false
        default: ''
      build_name:
        description: App version name (e.g. 1.0.0)
        required: false
        default: ''
      build_number:
        description: App build number (e.g. 1)
        required: false
        default: ''
  push:
    branches:
      - main
    paths:
      - 'ios/**'
      - '.github/workflows/build-ios-testflight.yml'

permissions:
  contents: read

env:
  # Prefer repository/environment variables; workflow inputs override if provided.
  IOS_BUNDLE_ID: ${{ inputs.bundle_id != '' && inputs.bundle_id || vars.IOS_BUNDLE_ID }}
  IOS_DEVELOPMENT_TEAM: ${{ inputs.team_id != '' && inputs.team_id || vars.IOS_DEVELOPMENT_TEAM }}

jobs:
  build-sign-upload:
    name: Build signed IPA and upload to TestFlight
    runs-on: macos-14
    timeout-minutes: 75

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Compute auth flags
        id: auth
        env:
          APPSTORE_PRIVATE_KEY: ${{ secrets.APPSTORE_PRIVATE_KEY }}
          APPSTORE_KEY_ID: ${{ secrets.APPSTORE_KEY_ID }}
          APPSTORE_ISSUER_ID: ${{ secrets.APPSTORE_ISSUER_ID }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APP_SPECIFIC_PASSWORD: ${{ secrets.APP_SPECIFIC_PASSWORD }}
          SIGNING_MODE: ${{ inputs.signing_mode }}
        shell: bash
        run: |
          set -e
          has_api="false"
          has_apple_id="false"
          if [ -n "$APPSTORE_PRIVATE_KEY" ] && [ -n "$APPSTORE_KEY_ID" ] && [ -n "$APPSTORE_ISSUER_ID" ]; then
            has_api="true"
          fi
          if [ -n "$APPLE_ID" ] && [ -n "$APP_SPECIFIC_PASSWORD" ]; then
            has_apple_id="true"
          fi
          # use_api respects an explicit manual override via input
          use_api="$has_api"
          if [ "${SIGNING_MODE:-auto}" = "manual" ]; then
            use_api="false"
          fi
          echo "has_api=$has_api" >> $GITHUB_OUTPUT
          echo "has_apple_id=$has_apple_id" >> $GITHUB_OUTPUT
          echo "use_api=$use_api" >> $GITHUB_OUTPUT

      - name: Set up Java (for Gradle/Android tooling used by Flutter)
        uses: actions/setup-java@v4
        with:
          distribution: 'zulu'
          java-version: '17'

      - name: Set up Flutter
        uses: subosito/flutter-action@v2
        with:
          channel: stable

      - name: Flutter version
        run: flutter --version

      - name: Flutter precache iOS
        run: flutter precache --ios

      - name: Cache pub packages
        uses: actions/cache@v4
        with:
          path: |
            ~/.pub-cache
            .dart_tool
          key: ${{ runner.os }}-pub-${{ hashFiles('pubspec.lock') }}

      - name: Cache CocoaPods
        uses: actions/cache@v4
        with:
          path: |
            ~/.cocoapods
            ios/Pods
          key: ${{ runner.os }}-pods-${{ hashFiles('ios/Podfile.lock') }}

      - name: Flutter pub get
        run: flutter pub get

      - name: Install CocoaPods dependencies (best-effort)
        if: ${{ hashFiles('ios/Podfile') != '' }}
        env:
          COCOAPODS_DISABLE_STATS: 'true'
        run: |
          set -e
          cd ios
          if command -v pod >/dev/null 2>&1; then
            pod install --repo-update || echo "pod install failed; continuing to let flutter build drive pods"
          else
            echo "CocoaPods not available; continuing"
          fi

      - name: Validate required inputs
        run: |
          set -e
          if [ -z "${IOS_BUNDLE_ID}" ]; then echo "Missing IOS_BUNDLE_ID (set vars.IOS_BUNDLE_ID or provide input bundle_id)"; exit 1; fi
          if [ -z "${IOS_DEVELOPMENT_TEAM}" ]; then echo "Missing IOS_DEVELOPMENT_TEAM (set vars.IOS_DEVELOPMENT_TEAM or provide input team_id)"; exit 1; fi

      - name: Import code signing certificate (.p12)
        id: import-certs
        uses: apple-actions/import-codesign-certs@v1
        with:
          p12-file-base64: ${{ secrets.IOS_CERT_P12_BASE64 }}
          p12-password: ${{ secrets.IOS_CERT_PASSWORD }}

      - name: "Preflight: verify Distribution certificate installed"
        run: |
          set -e
          echo "Listing installed code signing identities (expecting an 'Apple Distribution' identity with private key):"
          security find-identity -v -p codesigning || true
          if ! security find-identity -v -p codesigning | grep -q 'Apple Distribution'; then
            echo "Apple Distribution certificate not found in the keychain.\n\nChecks: \n- Ensure IOS_CERT_P12_BASE64 contains an Apple Distribution .p12 (not Development).\n- Ensure IOS_CERT_PASSWORD matches the .p12 export password.\n- The .p12 must include the private key.\n\nTip: Re-export with Keychain Access > My Certificates > 'Apple Distribution: <Team/Name>' > export as .p12 (include private key)." >&2
            exit 1
          fi

      - name: Write App Store Connect API key to file
        # Needed for -allowProvisioningUpdates (auto signing) or for potential future steps; harmless if unused
        if: steps.auth.outputs.has_api == 'true'
        # Needed for -allowProvisioningUpdates and TestFlight upload when using API key
        env:
          APPSTORE_PRIVATE_KEY: ${{ secrets.APPSTORE_PRIVATE_KEY }}
        run: |
          set -e
          echo "$APPSTORE_PRIVATE_KEY" > "$RUNNER_TEMP/AuthKey.p8"
          chmod 600 "$RUNNER_TEMP/AuthKey.p8"

      # When API key is provided, we'll use Automatic signing with -allowProvisioningUpdates
      # and let Xcode manage the profile. No need to download a profile.

      - name: Install provisioning profile from secret (base64)
        if: steps.auth.outputs.use_api != 'true'
        env:
          IOS_MOBILEPROVISION_BASE64: ${{ secrets.IOS_MOBILEPROVISION_BASE64 }}
        run: |
          set -e
          mkdir -p "${HOME}/Library/MobileDevice/Provisioning Profiles"
          if [ -z "$IOS_MOBILEPROVISION_BASE64" ]; then echo "IOS_MOBILEPROVISION_BASE64 not set"; exit 1; fi
          echo "Installing provisioning profile from IOS_MOBILEPROVISION_BASE64"
          echo "$IOS_MOBILEPROVISION_BASE64" | base64 --decode > "${HOME}/Library/MobileDevice/Provisioning Profiles/profile.mobileprovision"

      - name: Fail if no provisioning profile configured
        if: steps.auth.outputs.use_api != 'true'
        env:
          IOS_MOBILEPROVISION_BASE64: ${{ secrets.IOS_MOBILEPROVISION_BASE64 }}
        run: |
          if [ -z "$IOS_MOBILEPROVISION_BASE64" ]; then
            echo "No provisioning profile available. Provide either API key secrets (APPSTORE_PRIVATE_KEY/KEY_ID/ISSUER_ID) or a base64 provisioning profile in IOS_MOBILEPROVISION_BASE64." >&2
            exit 1
          fi

      - name: Resolve provisioning profile name (manual signing only)
        if: steps.auth.outputs.use_api != 'true'
        id: profile
        shell: bash
        run: |
          set -e
          PROFILE_PATH=$(ls -1 "${HOME}/Library/MobileDevice/Provisioning Profiles"/*.mobileprovision | head -n1)
          if [ ! -f "$PROFILE_PATH" ]; then echo "No provisioning profile found"; exit 1; fi
          /usr/bin/security cms -D -i "$PROFILE_PATH" -o profile.plist
          NAME=$(/usr/libexec/PlistBuddy -c 'Print :Name' profile.plist)
          UUID=$(/usr/libexec/PlistBuddy -c 'Print :UUID' profile.plist)
          echo "Profile: $NAME ($UUID)"
          echo "name=$NAME" >> $GITHUB_OUTPUT
          echo "uuid=$UUID" >> $GITHUB_OUTPUT

      - name: "Preflight: validate provisioning profile (manual signing only)"
        if: steps.auth.outputs.use_api != 'true'
        env:
          IOS_BUNDLE_ID: ${{ env.IOS_BUNDLE_ID }}
          IOS_DEVELOPMENT_TEAM: ${{ env.IOS_DEVELOPMENT_TEAM }}
        run: |
          set -e
          if [ ! -f profile.plist ]; then echo "profile.plist missing; previous step should have created it"; exit 1; fi
          TEAM=$(/usr/libexec/PlistBuddy -c 'Print :TeamIdentifier:0' profile.plist)
          APPID=$(/usr/libexec/PlistBuddy -c 'Print :Entitlements:application-identifier' profile.plist)
          ENV=$(/usr/libexec/PlistBuddy -c 'Print :Entitlements:aps-environment' profile.plist 2>/dev/null || echo '')
          HAS_DEVICES=0
          /usr/libexec/PlistBuddy -c 'Print :ProvisionedDevices' profile.plist >/dev/null 2>&1 || HAS_DEVICES=$?
          echo "Team in profile: $TEAM"
          echo "Application Identifier in profile: $APPID"
          if [ "$TEAM" != "$IOS_DEVELOPMENT_TEAM" ]; then
            echo "Provisioning profile TeamIdentifier ($TEAM) does not match IOS_DEVELOPMENT_TEAM ($IOS_DEVELOPMENT_TEAM)." >&2
            exit 1
          fi
          if [ "$APPID" != "${IOS_DEVELOPMENT_TEAM}.${IOS_BUNDLE_ID}" ]; then
            echo "Provisioning profile application-identifier ($APPID) does not match expected ${IOS_DEVELOPMENT_TEAM}.${IOS_BUNDLE_ID}." >&2
            exit 1
          fi
          # For App Store profiles, ProvisionedDevices should NOT exist and aps-environment should be 'production' or unset.
          if [ $HAS_DEVICES -eq 0 ]; then
            echo "Profile contains ProvisionedDevices -> likely Development/Ad Hoc profile. Use an App Store (Distribution) profile." >&2
            exit 1
          fi
          if [ "$ENV" = "development" ]; then
            echo "Profile aps-environment is 'development' -> likely Development profile. Use an App Store (Distribution) profile." >&2
            exit 1
          fi

      - name: Archive (Xcode)
        env:
          USE_API: ${{ steps.auth.outputs.use_api }}
        run: |
          # Clean any previous DerivedData to avoid stale signing artefacts
          rm -rf ~/Library/Developer/Xcode/DerivedData || true
          set -euo pipefail
          mkdir -p build/ios/archive build/ios/logs
          echo "Listing Xcode schemes to verify 'Runner' exists:"
          xcodebuild -list -workspace ios/Runner.xcworkspace || true
          AUTH_ARGS=()
          if [ "${USE_API}" = "true" ]; then
            AUTH_ARGS+=(
              -allowProvisioningUpdates
              -authenticationKeyPath "$RUNNER_TEMP/AuthKey.p8"
              -authenticationKeyID "${{ secrets.APPSTORE_KEY_ID }}"
              -authenticationKeyIssuerID "${{ secrets.APPSTORE_ISSUER_ID }}"
            )
          fi
          SIGN_ARGS=()
          if [ "${USE_API}" = "true" ]; then
            # Force Distribution identity to avoid Xcode drifting to Development during archive
            # Use Automatic signing and let Xcode select the correct identities/profiles.
            # Do NOT force CODE_SIGN_IDENTITY globally, as it conflicts with CocoaPods targets.
            # Explicitly clear CODE_SIGN_IDENTITY to avoid any lingering manual identity overriding Automatic signing.
            SIGN_ARGS+=(CODE_SIGN_STYLE=Automatic CODE_SIGN_IDENTITY="")
            # If keychain path is available from import-certs, pass it explicitly (defensive)
            if [ -n "${{ steps.import-certs.outputs.keychain-path }}" ]; then
              SIGN_ARGS+=(OTHER_CODE_SIGN_FLAGS="--keychain ${{ steps.import-certs.outputs.keychain-path }}")
            fi
          else
            SIGN_ARGS+=(CODE_SIGN_STYLE=Manual PROVISIONING_PROFILE_SPECIFIER='${{ steps.profile.outputs.name }}' CODE_SIGN_IDENTITY="Apple Distribution")
          fi
          # Build the command with safe array expansions (avoid unbound errors under set -u)
          echo "xcodebuild command (sanitized): xcodebuild -workspace ios/Runner.xcworkspace -scheme Runner -configuration Release -destination 'generic/platform=iOS' -archivePath build/ios/archive/Runner.xcarchive DEVELOPMENT_TEAM=${IOS_DEVELOPMENT_TEAM} PRODUCT_BUNDLE_IDENTIFIER=${IOS_BUNDLE_ID} CODE_SIGNING_REQUIRED=YES CODE_SIGNING_ALLOWED=YES ${SIGN_ARGS[@]+${SIGN_ARGS[@]}} clean archive ${AUTH_ARGS[@]+${AUTH_ARGS[@]}}"
          xcodebuild \
            -workspace ios/Runner.xcworkspace \
            -scheme Runner \
            -configuration Release \
            -destination 'generic/platform=iOS' \
            -archivePath build/ios/archive/Runner.xcarchive \
            DEVELOPMENT_TEAM=${IOS_DEVELOPMENT_TEAM} \
            PRODUCT_BUNDLE_IDENTIFIER=${IOS_BUNDLE_ID} \
            CODE_SIGNING_REQUIRED=YES CODE_SIGNING_ALLOWED=YES \
            ${SIGN_ARGS[@]+"${SIGN_ARGS[@]}"} \
            clean archive \
            ${AUTH_ARGS[@]+"${AUTH_ARGS[@]}"} \
            | tee build/ios/logs/xcodebuild-archive.log
          echo "\nSelected signing identity during archive (detected from build settings):" || true
          xcodebuild -showBuildSettings -workspace ios/Runner.xcworkspace -scheme Runner -configuration Release | grep -E "CODE_SIGN_IDENTITY|CODE_SIGN_STYLE" || true

      - name: Create exportOptions.plist (App Store)
        env:
          USE_API: ${{ steps.auth.outputs.use_api }}
        run: |
          if [ "${USE_API}" = "true" ]; then
            cat > exportOptions.plist <<EOF
            <?xml version="1.0" encoding="UTF-8"?>
            <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
            <plist version="1.0">
            <dict>
              <key>method</key>
              <string>app-store</string>
              <key>signingStyle</key>
              <string>automatic</string>
              <key>teamID</key>
              <string>${IOS_DEVELOPMENT_TEAM}</string>
              <key>compileBitcode</key>
              <false/>
              <key>uploadSymbols</key>
              <true/>
              <key>manageAppVersionAndBuildNumber</key>
              <true/>
            </dict>
            </plist>
            EOF
          else
            cat > exportOptions.plist <<EOF
            <?xml version="1.0" encoding="UTF-8"?>
            <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
            <plist version="1.0">
            <dict>
              <key>method</key>
              <string>app-store</string>
              <key>signingStyle</key>
              <string>manual</string>
              <key>teamID</key>
              <string>${IOS_DEVELOPMENT_TEAM}</string>
              <key>provisioningProfiles</key>
              <dict>
                <key>${IOS_BUNDLE_ID}</key>
                <string>${{ steps.profile.outputs.name }}</string>
              </dict>
              <key>compileBitcode</key>
              <false/>
              <key>uploadSymbols</key>
              <true/>
              <key>manageAppVersionAndBuildNumber</key>
              <true/>
            </dict>
            </plist>
            EOF
          fi

      - name: Export signed IPA
        env:
          USE_API: ${{ steps.auth.outputs.use_api }}
        run: |
          set -euo pipefail
          mkdir -p build/ios/ipa build/ios/logs
          # Optionally set version/build via xcodebuild overrides if provided
          EXTRA_BUILD_ARGS=()
          if [ -n "${{ inputs.build_name }}" ]; then EXTRA_BUILD_ARGS+=(MARKETING_VERSION=${{ inputs.build_name }}); fi
          if [ -n "${{ inputs.build_number }}" ]; then EXTRA_BUILD_ARGS+=(CURRENT_PROJECT_VERSION=${{ inputs.build_number }}); fi
          AUTH_ARGS=()
          if [ "${USE_API}" = "true" ]; then
            AUTH_ARGS+=(
              -allowProvisioningUpdates
              -authenticationKeyPath "$RUNNER_TEMP/AuthKey.p8"
              -authenticationKeyID "${{ secrets.APPSTORE_KEY_ID }}"
              -authenticationKeyIssuerID "${{ secrets.APPSTORE_ISSUER_ID }}"
            )
          fi
          # Clear CODE_SIGN_IDENTITY when exporting too, to avoid conflicts
          xcodebuild -exportArchive \
            -archivePath build/ios/archive/Runner.xcarchive \
            -exportOptionsPlist exportOptions.plist \
            -exportPath build/ios/ipa \
            CODE_SIGN_IDENTITY="" \
            ${AUTH_ARGS[@]+"${AUTH_ARGS[@]}"} \
            ${EXTRA_BUILD_ARGS[@]+"${EXTRA_BUILD_ARGS[@]}"} \
            | tee build/ios/logs/xcodebuild-export.log

      - name: Upload to TestFlight (API key)
        if: steps.auth.outputs.has_api == 'true'
        uses: apple-actions/upload-testflight-build@v1
        with:
          app-path: build/ios/ipa/*.ipa
          issuer-id: ${{ secrets.APPSTORE_ISSUER_ID }}
          api-key-id: ${{ secrets.APPSTORE_KEY_ID }}
          api-private-key: ${{ secrets.APPSTORE_PRIVATE_KEY }}

      - name: Upload to TestFlight (Apple ID + app-specific password)
        if: steps.auth.outputs.has_api != 'true'
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APP_SPECIFIC_PASSWORD: ${{ secrets.APP_SPECIFIC_PASSWORD }}
          ITC_PROVIDER: ${{ secrets.ITC_PROVIDER }}
        run: |
          set -e
          IPA=$(ls -1 build/ios/ipa/*.ipa | head -n1)
          if [ ! -f "$IPA" ]; then echo "IPA not found"; exit 1; fi
          echo "Uploading via iTMSTransporter using Apple ID"
          # Optional provider short name (when Apple ID is in multiple teams)
          if [ -z "$APPLE_ID" ] || [ -z "$APP_SPECIFIC_PASSWORD" ]; then echo "APPLE_ID/APP_SPECIFIC_PASSWORD not set"; exit 1; fi
          if [ -n "$ITC_PROVIDER" ]; then
            xcrun iTMSTransporter -m upload -assetFile "$IPA" -u "$APPLE_ID" -p "$APP_SPECIFIC_PASSWORD" -itc_provider "$ITC_PROVIDER" -repetitionAttempts 3 -v informational
          else
            xcrun iTMSTransporter -m upload -assetFile "$IPA" -u "$APPLE_ID" -p "$APP_SPECIFIC_PASSWORD" -repetitionAttempts 3 -v informational
          fi

      - name: Fail upload if no credentials provided
        if: steps.auth.outputs.has_api != 'true'
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APP_SPECIFIC_PASSWORD: ${{ secrets.APP_SPECIFIC_PASSWORD }}
        run: |
          if [ -z "$APPLE_ID" ] || [ -z "$APP_SPECIFIC_PASSWORD" ]; then
            echo "No TestFlight upload credentials provided. Provide API key secrets or APPLE_ID + APP_SPECIFIC_PASSWORD (and optional ITC_PROVIDER)." >&2
            exit 1
          fi

      - name: Upload artifacts (IPA + XCArchive)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: ios-signed-artifacts
          path: |
            build/ios/ipa/*.ipa
            build/ios/archive/*.xcarchive
            build/ios/logs/*.log
          retention-days: 7
